# RDBMS 핵심 개념 정리

---

### RDBMS(관계형 데이터베이스 관리 시스템)란?

**RDBMS**는 **관계형 모델**에 기반하여 데이터를 저장, 관리, 검색하는 시스템입니다. 데이터를 **테이블(Table)**, **행(Row)**, **열(Column)**의 형태로 구성하며, 이 테이블들은 서로 **관계(Relation)**를 맺어 데이터를 효율적으로 구조화하고 관리합니다.

* **주요 특징**:
    * **정규화(Normalization)**를 통해 데이터 중복을 최소화하고 일관성을 유지합니다.
    * **ACID 트랜잭션**을 지원하여 데이터 무결성을 보장합니다.
    * **SQL(Structured Query Language)**을 사용하여 데이터를 조작하고 관리합니다.
    * 데이터의 **스키마(Schema)**가 명확하게 정의되어 있어 구조적입니다.
* **대표적인 RDBMS**: MySQL, PostgreSQL, Oracle, MS-SQL, DB2, MariaDB 등

---

### 데이터베이스 정규화(Normalization)

**정규화**는 데이터베이스의 **논리적 설계 단계**에서 중복을 최소화하고 데이터 무결성을 높이기 위해 데이터를 구조화하는 과정입니다. 여러 정규형(1NF, 2NF, 3NF, BCNF 등)이 있으며, 일반적으로 3차 정규형까지 만족시키는 것을 목표로 합니다.

* **정규화의 목적**:
    * 데이터 중복 제거를 통한 저장 공간 절약 및 일관성 유지.
    * **이상(Anomaly) 현상 방지**:
        * **삽입 이상(Insertion Anomaly)**: 불필요한 데이터를 삽입해야만 새 데이터를 추가할 수 있는 문제.
        * **삭제 이상(Deletion Anomaly)**: 유의미한 데이터의 일부가 함께 삭제되는 문제.
        * **갱신 이상(Update Anomaly)**: 중복된 데이터 중 일부만 갱신되어 데이터 불일치가 발생하는 문제.
* **비정규화(Denormalization)**: 성능 향상을 위해 의도적으로 정규화 원칙을 위배하고 중복을 허용하는 과정. (읽기 성능이 중요할 때 사용)

---

### 트랜잭션(Transaction)

**트랜잭션**은 데이터베이스의 상태를 변화시키기 위해 수행하는 **하나의 논리적인 작업 단위**입니다. 모든 연산이 성공적으로 완료되거나, 아니면 전부 실패하여 원래 상태로 되돌리는 **원자성(Atomicity)**이 중요합니다.

* **ACID 속성**: 트랜잭션의 안정성과 무결성을 보장하는 핵심 속성입니다.
    * **원자성(Atomicity)**: 트랜잭션 내의 모든 연산은 완전히 성공하거나, 완전히 실패하여 아무것도 수행되지 않은 상태로 롤백(Rollback)되어야 합니다. (All or Nothing)
    * **일관성(Consistency)**: 트랜잭션이 성공적으로 완료되면 데이터베이스는 항상 일관된 상태를 유지해야 합니다.
    * **격리성(Isolation)**: 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 독립적으로 실행되는 것처럼 보여야 합니다. 중간 결과가 다른 트랜잭션에 노출되지 않습니다.
    * **영속성(Durability)**: 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템 오류(하드웨어 오류, 정전 등)와 관계없이 영구적으로 데이터베이스에 반영되어야 합니다.

---

### 인덱스(Index)

**인덱스**는 데이터베이스 테이블의 검색 속도를 향상시키기 위한 **자료 구조**입니다. 책의 목차나 찾아보기와 유사하게, 데이터를 빠르게 찾을 수 있도록 돕습니다.

* **동작 원리**: 주로 B-Tree 또는 B+Tree 구조로 구현됩니다. 특정 컬럼의 값을 기준으로 정렬된 별도의 저장 공간을 만들어 놓아, 데이터 조회 시 테이블 전체를 스캔(Full Table Scan)하지 않고 인덱스를 통해 빠르게 원하는 행을 찾을 수 있습니다.
* **장점**:
    * 데이터 **검색 속도 향상** (`SELECT` 문).
    * 정렬(`ORDER BY`)이나 그룹화(`GROUP BY`) 작업 시 성능 향상.
* **단점**:
    * 데이터 변경(삽입, 수정, 삭제) 시 인덱스도 함께 갱신되어야 하므로 **성능 저하**가 발생할 수 있습니다.
    * 추가적인 **저장 공간**이 필요합니다.
* **인덱스 종류**:
    * **클러스터드 인덱스(Clustered Index)**: 테이블의 물리적 저장 순서를 인덱스 순서에 맞게 정렬합니다. 테이블당 하나만 가질 수 있으며, 주로 Primary Key에 자동 생성됩니다.
    * **논클러스터드 인덱스(Non-Clustered Index)**: 인덱스와 실제 데이터가 별도로 저장됩니다. 인덱스는 데이터의 물리적 위치(RID, Row ID)를 가리키며, 여러 개 생성 가능합니다.

---

### 조인(JOIN)

**조인**은 두 개 이상의 테이블에서 공통된 컬럼(키)을 기준으로 데이터를 **연결**하여 새로운 결과 집합을 만드는 SQL 연산입니다.

* **조인 종류**:
    * **INNER JOIN (내부 조인)**: 두 테이블에 모두 **일치하는 행**만 반환합니다. 가장 일반적으로 사용됩니다.
    * **LEFT JOIN (LEFT OUTER JOIN)**: 왼쪽 테이블의 모든 행과 오른쪽 테이블에서 일치하는 행을 반환합니다. 일치하는 행이 없으면 오른쪽 테이블의 컬럼은 `NULL`로 채워집니다.
    * **RIGHT JOIN (RIGHT OUTER JOIN)**: 오른쪽 테이블의 모든 행과 왼쪽 테이블에서 일치하는 행을 반환합니다. 일치하는 행이 없으면 왼쪽 테이블의 컬럼은 `NULL`로 채워집니다.
    * **FULL JOIN (FULL OUTER JOIN)**: 양쪽 테이블의 모든 행을 반환합니다. 일치하는 행이 없으면 `NULL`로 채워집니다.
    * **CROSS JOIN (카티션 곱)**: 두 테이블의 모든 가능한 행 조합(데카르트 곱)을 반환합니다. 명시적인 조인 조건이 없을 때 발생합니다.
    * **SELF JOIN**: 같은 테이블을 두 번 사용하여 자신을 조인하는 방식입니다. 주로 계층형 데이터를 조회할 때 사용됩니다.

---

### 뷰(View)

**뷰**는 하나 이상의 테이블이나 다른 뷰의 데이터를 기반으로 하는 **가상 테이블**입니다. 실제 데이터는 저장하지 않고, 질의가 실행될 때마다 원본 테이블에서 데이터를 가져와 보여줍니다.

* **장점**:
    * **보안성**: 특정 컬럼이나 행만 보여줌으로써 사용자별 데이터 접근을 제한할 수 있습니다.
    * **편의성**: 복잡한 쿼리를 미리 정의해두고 뷰를 통해 간단하게 데이터를 조회할 수 있습니다.
    * **데이터 독립성**: 기본 테이블 구조가 변경되어도 뷰를 사용하는 애플리케이션에 미치는 영향을 최소화할 수 있습니다.
* **단점**:
    * 성능 저하의 가능성 (복잡한 뷰의 경우).
    * 제약 사항 (업데이트/삽입/삭제가 제한되는 경우).

---

### 저장 프로시저(Stored Procedure)

**저장 프로시저**는 SQL 문들의 집합으로, 특정 작업을 수행하기 위해 **데이터베이스에 미리 저장해 둔 절차형 SQL 코드**입니다. 필요할 때 호출하여 실행할 수 있습니다.

* **장점**:
    * **성능 향상**: 미리 컴파일되어 저장되므로 실행 속도가 빠릅니다. 네트워크 트래픽도 감소합니다.
    * **재사용성**: 반복되는 작업을 프로시저로 만들어 여러 곳에서 재사용할 수 있습니다.
    * **보안성**: 사용자에게 테이블에 대한 직접적인 권한 없이 프로시저 실행 권한만 부여하여 보안을 강화할 수 있습니다.
    * **유지보수 용이**: 비즈니스 로직을 데이터베이스에 중앙 집중화하여 관리할 수 있습니다.
* **단점**:
    * **개발 및 테스트의 어려움**: 데이터베이스 벤더 종속적이며, 디버깅 도구가 제한적일 수 있습니다.
    * **성능 이슈**: 과도한 사용 시 데이터베이스 서버에 부하를 줄 수 있습니다.

---

### 데이터베이스 무결성(Integrity)

**데이터베이스 무결성**은 데이터의 **정확성, 일관성, 유효성**을 유지하는 것을 의미합니다. 데이터의 품질과 신뢰성을 보장하는 핵심 개념입니다.

* **주요 무결성 제약 조건**:
    * **개체 무결성(Entity Integrity)**: 기본 키(Primary Key)는 `NULL` 값을 가질 수 없으며 중복될 수 없습니다.
    * **참조 무결성(Referential Integrity)**: 외래 키(Foreign Key)는 참조하는 기본 키의 값과 일치하거나 `NULL` 값을 가져야 합니다. (없는 값을 참조할 수 없음)
    * **도메인 무결성(Domain Integrity)**: 특정 컬럼의 값이 미리 정의된 도메인(데이터 타입, 범위, 형식)을 벗어날 수 없습니다.
    * **사용자 정의 무결성(User-Defined Integrity)**: 특정 애플리케이션의 비즈니스 규칙에 따라 정의하는 제약 조건입니다. (예: `CHECK` 제약 조건)

---

### SQL(Structured Query Language)

**SQL**은 RDBMS에서 데이터를 정의(DDL), 조작(DML), 제어(DCL)하고 조회(DQL)하는 데 사용되는 **표준 언어**입니다.

* **DDL (Data Definition Language - 데이터 정의어)**: 데이터베이스 객체(테이블, 뷰, 인덱스 등)를 생성, 수정, 삭제합니다.
    * `CREATE`, `ALTER`, `DROP`, `TRUNCATE`
* **DML (Data Manipulation Language - 데이터 조작어)**: 테이블의 데이터를 삽입, 수정, 삭제합니다.
    * `INSERT`, `UPDATE`, `DELETE`
* **DCL (Data Control Language - 데이터 제어어)**: 데이터 접근 권한을 부여하거나 회수하고, 트랜잭션을 제어합니다.
    * `GRANT`, `REVOKE`, `COMMIT`, `ROLLBACK`, `SAVEPOINT`
* **DQL (Data Query Language - 데이터 질의어)**: 데이터를 조회합니다.
    * `SELECT`