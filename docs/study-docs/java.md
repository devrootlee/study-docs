# JAVA 핵심 개념 정리

---

### 자바(JAVA)란 무엇인가?

자바는 **오라클**에서 제공하는 **객체 지향 프로그래밍 언어**로, 강력한 **플랫폼 독립성**과 **높은 안정성**을 자랑합니다.

* **플랫폼 독립성**: **JVM(Java Virtual Machine)**을 통해 '한 번 작성하면 어디서든 실행(Write Once, Run Anywhere)'이 가능합니다.
* **객체 지향 프로그래밍(OOP)**: **캡슐화, 상속, 다형성**과 같은 OOP 특징을 지원하여 유지보수 및 재사용성이 뛰어납니다.
* **자동 메모리 관리**: **가비지 컬렉션(Garbage Collection)**을 통해 사용하지 않는 메모리를 자동으로 회수합니다.
* **풍부한 라이브러리 및 프레임워크**: Spring, Hibernate 등 강력한 프레임워크 덕분에 대규모 시스템 개발에 용이합니다.
* **멀티스레딩 지원**: 멀티스레드를 기본 지원하여 동시성 프로그래밍을 쉽게 할 수 있습니다.
* **보안성**: 바이트코드 검증과 샌드박스 실행 환경을 제공하여 높은 보안성을 가집니다.

---

### JAVA의 동작 순서

자바 코드가 실행되는 과정은 다음과 같습니다.

1.  **컴파일**: **자바 컴파일러(`javac`)**가 자바 소스코드(`.java`)를 읽어 **자바 바이트코드(`.class`)**로 변환합니다.
2.  **클래스 로딩**: **Class Loader**를 통해 `.class` 파일들이 **JVM**으로 로드됩니다.
3.  **실행**: 로드된 `.class` 파일들이 **Execution Engine**을 통해 해석됩니다.
4.  **수행**: 해석된 바이트코드는 **Runtime Data Areas**에 배치되어 실제 프로그램이 수행됩니다.

---

### JVM 구조 및 역할 심화

**JVM(Java Virtual Machine)**은 자바 바이트코드를 실행하는 가상 머신으로, 자바의 플랫폼 독립성을 가능하게 합니다.

* **클래스 로더 시스템 (Class Loader System)**: `.class` 파일들을 JVM으로 동적으로 로드합니다. 로딩, 링크(검증, 준비, 분석), 초기화 단계를 거칩니다.
* **런타임 데이터 영역 (Runtime Data Areas)**: 프로그램을 실행하기 위해 데이터를 보관하는 메모리 공간입니다.
    * **메서드 영역 (Method Area)**: 클래스 정보(클래스, 인터페이스, 필드, 메서드, 생성자 정보 등)와 `static` 변수 등이 저장됩니다.
    * **힙 영역 (Heap Area)**: 인스턴스(객체)가 생성되는 공간입니다. 대부분의 객체는 여기에 저장되며, GC의 주된 대상입니다.
    * **스택 영역 (Stack Area)**: 메서드 호출 시 지역 변수, 파라미터, 리턴 주소 등이 임시로 저장되는 공간입니다. 메서드 호출마다 프레임이 생성되고, 메서드 종료 시 프레임이 제거됩니다.
    * **PC 레지스터 (PC Register)**: 현재 스레드가 실행될 JVM 명령어의 주소를 저장합니다.
    * **네이티브 메서드 스택 (Native Method Stack)**: 자바가 아닌 다른 언어(C/C++)로 작성된 네이티브 메서드의 호출 정보를 저장합니다.
* **실행 엔진 (Execution Engine)**: 로드된 바이트코드를 실행합니다.
    * **인터프리터 (Interpreter)**: 바이트코드를 한 줄씩 읽어 바로 실행합니다.
    * **JIT 컴파일러 (Just-In-Time Compiler)**: 인터프리터의 비효율성을 개선하기 위해 도입되었습니다. 반복적으로 실행되는 코드를 감지하여 네이티브 코드로 컴파일하고 캐싱하여 다음 실행 시 빠르게 동작하도록 합니다.
    * **가비지 컬렉터 (Garbage Collector)**: 힙 영역에서 사용되지 않는 객체를 제거하여 메모리를 관리합니다.

---

### GC (Garbage Collection)

**GC**는 **힙(Heap) 영역**에서 더 이상 사용하지 않는 객체들을 자동으로 제거하는 작업입니다. 자바는 개발자가 메모리를 직접 해제할 수 없기 때문에, GC는 메모리 누수를 방지하고 효율적인 메모리 관리를 위해 필수적입니다.

* **동작 원리**:
    * **Mark (마킹)**: GC가 스택, 정적 변수 등 Root Set에서부터 객체를 추적하여 도달 가능한(Reachability) 객체들을 마킹합니다.
    * **Sweep (제거)**: 마킹되지 않은(도달 불가능한) 객체들을 힙에서 제거합니다.
    * **Compact (압축)**: 파편화된 메모리 공간을 한곳으로 모아 새로운 객체를 할당할 공간을 확보합니다. (선택 사항)
* **Minor GC vs Major GC/Full GC**:
    * **Minor GC**: Young Generation(새로 생성된 객체들이 저장되는 공간)에서 발생하는 GC입니다. 비교적 짧은 시간 안에 자주 일어납니다.
    * **Major GC / Full GC**: Old Generation(오래 살아남은 객체들이 저장되는 공간)에서 발생하는 GC입니다. Minor GC보다 시간이 오래 걸리고 시스템에 부하를 줄 수 있습니다.
* **GC 알고리즘**: Mark-Sweep-Compact 외에도 Generational Collection, Serial GC, Parallel GC, CMS GC, G1 GC, Shenandoah GC, ZGC 등 다양한 알고리즘이 존재하며, 각각의 장단점이 있어 워크로드에 따라 적절한 GC를 선택하고 튜닝할 수 있습니다.

---

### 제네릭(Generic)

**제네릭**은 자바에서 **타입(데이터 형식)을 파라미터화**하여 사용하는 기능입니다. 클래스, 인터페이스, 메서드 등을 정의할 때 타입을 미리 지정하지 않고, 실제 사용할 때 타입을 지정하여 **컴파일 시 타입 안정성**을 확보하고 코드의 **재사용성, 유지보수성**을 향상시킬 수 있습니다.

* **장점**:
    * **타입 안정성**: 잘못된 타입의 객체가 저장되는 것을 컴파일 시점에서 방지합니다.
    * **타입 체크 및 형 변환 생략**: 불필요한 타입 캐스팅을 줄여 코드를 간결하게 합니다.
    * **코드 재사용성**: 하나의 코드로 여러 타입에 대응할 수 있습니다.

---

### 어노테이션(Annotation)

**어노테이션**은 코드에 **메타 정보**(코드 자체에 대한 추가 정보)를 추가하는 용도로 사용됩니다. 컴파일러에게 추가 정보를 제공하거나, 런타임 시 특정 도구나 프레임워크가 해당 메타 정보를 사용하여 코드를 처리하는 데 도움을 줍니다.

* **주요 용도**:
    * **컴파일러 정보 제공**: 컴파일러 경고 억제(`@SuppressWarnings`), 오버라이드 여부(`@Override`) 등
    * **코드 생성 또는 처리**: Lombok 같은 라이브러리가 어노테이션을 통해 코드를 자동 생성
    * **런타임 처리**: Spring의 `@Autowired`, `@Controller` 등 프레임워크가 런타임에 어노테이션 정보를 읽어 동작을 제어

---

### 오버라이딩(Overriding) vs 오버로딩(Overloading)

* **오버라이딩(Overriding)**: **상속 관계**에서 부모 클래스의 메서드를 자식 클래스에서 **재정의**하는 것입니다. 메서드의 이름, 반환 타입, 매개변수 목록이 모두 부모 메서드와 동일해야 합니다. 다형성(Polymorphism)을 구현하는 핵심 메커니즘입니다.
* **오버로딩(Overloading)**: 하나의 클래스 내에서 **동일한 이름**의 메서드를 **여러 번 정의**하는 것입니다. 이때 매개변수의 개수, 타입, 순서 중 하나 이상이 달라야 합니다. 반환 타입은 오버로딩에 영향을 주지 않습니다.

---

### 인터페이스(Interface) vs 추상 클래스(Abstract Class)

| 특징         | 인터페이스(Interface)                                                                                                              | 추상 클래스(Abstract Class)                                                                                                    |
| :----------- | :--------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------- |
| **목적** | 구현 객체가 같은 동작을 한다는 것을 **보장** (행위의 규약)                                                                       | 객체의 **추상적인 상위 개념**으로 공통된 특징 및 기능을 표현                                                                 |
| **상속/구현** | 클래스는 다중 **구현** 가능 (implements)                                                                                           | 클래스는 단일 **상속**만 가능 (extends)                                                                                        |
| **관계** | 구현하는 객체 간에 **관계가 없을 수 있음** (예: `Runnable` 인터페이스를 구현하는 다양한 종류의 객체)                             | 상속하는 집합 간에 **연관 관계** (Is-a 관계)가 존재                                                                         |
| **메서드** | JDK 8부터 `default` 메서드(구현체 포함), `static` 메서드 추가. 그 이전엔 추상 메서드만 가능                                        | 추상 메서드와 구현된 메서드 모두 포함 가능                                                                                   |
| **변수** | `public static final` (상수)만 선언 가능                                                                                           | 일반 변수 및 상수 모두 선언 가능                                                                                               |
| **생성자** | 생성자 없음                                                                                                                        | 생성자 가질 수 있음 (하지만 직접 인스턴스화 불가능, 자식 클래스 생성 시 호출)                                                 |

---

### 객체(Instance) vs 클래스(Class)

* **객체(Instance)**: 소프트웨어 세계에 구현될 **실체**입니다. 구별 가능한 식별자(메모리 주소), 특징적인 행동(메서드), 변경 가능한 상태(필드 값)를 가집니다. 클래스로부터 생성된 인스턴스들을 통칭하는 용어로도 사용됩니다.
* **클래스(Class)**: 객체를 정의하는 **틀** 또는 **설계도**와 같은 의미로 사용됩니다. 객체가 가져야 할 속성(필드)과 기능(메서드)을 정의하며, 클래스 없이는 객체를 생성할 수 없습니다.

---

### 정적(Static) 키워드

`static` 키워드는 객체 지향 프로그래밍에서 클래스에 속한 멤버(변수, 메서드, 이너 클래스, 초기화 블록 등)에 대한 특성을 정의합니다. `static`이 붙은 멤버는 **객체마다 별도로 존재하는 것이 아니라**, 클래스가 JVM에 로드될 때 **한 번만 메모리(메서드 영역)에 할당**되어 모든 객체에서 **공유**됩니다.

* **정적 변수 (Static Variable)**: 모든 객체가 공유하는 변수입니다. 객체를 생성하지 않고도 `클래스명.변수명`으로 직접 접근할 수 있습니다.
* **정적 메서드 (Static Method)**: 객체 생성 없이 `클래스명.메서드명()`으로 직접 호출할 수 있는 메서드입니다. `static` 메서드 내에서는 `static` 멤버만 직접 접근할 수 있고, `this` 키워드를 사용할 수 없습니다.

---

### 기본형(Primitive Type) vs 참조형(Reference Type)

| 특징         | 기본형(Primitive Type)                                    | 참조형(Reference Type)                                  |
| :----------- | :-------------------------------------------------------- | :------------------------------------------------------ |
| **저장 위치** | 값 자체를 **스택(Stack) 영역**에 저장                     | **힙(Heap) 영역**에 객체 데이터를 저장하고, **스택**에는 해당 객체의 **주소값(참조값)**을 저장 |
| **값 저장** | 실제 데이터 값                                            | 객체의 메모리 주소(참조)                                |
| **종류** | `byte`(1), `short`(2), `int`(4), `long`(8), `float`(4), `double`(8), `char`(2), `boolean`(1) | `class`, `interface`, `array`, `enum`, `String`, Wrapper 클래스(`Character`, `Integer`, `Double` ~), Collection 프레임워크(`List`, `Map`, `Set` ~) |
| **`null` 여부** | `null` 값을 가질 수 없음 (각 타입의 기본값으로 초기화)  | `null` 값을 가질 수 있음                                |
| **크기** | 정해진 고정 크기 (예: `int` 4바이트)                      | 객체 내용에 따라 가변적이며, 주소값의 크기는 고정      |

---

### 컬렉션 프레임워크(Collection Framework)

**자바 컬렉션 프레임워크**는 널리 알려진 **자료구조(Data Structure)**와 **알고리즘(Algorithm)**을 바탕으로 객체나 데이터들을 효율적으로 저장, 관리, 검색할 수 있도록 제공되는 **표준화된 라이브러리**입니다.

* **주요 인터페이스**:
    * **`Collection` 인터페이스**: 객체의 집합을 나타내는 최상위 인터페이스입니다. `List`와 `Set`이 상속받습니다.
        * **`List`**: **순서가 있는** 데이터의 집합이며, **중복을 허용**합니다. (예: `ArrayList`, `LinkedList`, `Vector`)
        * **`Set`**: **순서가 없으며**, **중복을 허용하지 않는** 데이터의 집합입니다. (예: `HashSet`, `TreeSet`, `LinkedHashSet`)
    * **`Map` 인터페이스**: `Collection` 인터페이스와는 별도로 정의되며, **키(Key)-값(Value) 쌍**으로 데이터를 관리합니다. 키는 중복될 수 없지만 값은 중복될 수 있습니다. (예: `HashMap`, `TreeMap`, ``LinkedHashMap`, `Hashtable`)

---

### 예외 처리 (Exception Handling)

**예외(Exception)**는 프로그램 실행 중 발생하는 오류나 예상치 못한 상황을 의미합니다. 자바의 예외 처리는 이러한 문제를 적절히 처리하여 프로그램의 안정성을 높이는 메커니즘입니다.

* **`Error` vs `Exception`**:
    * **`Error`**: 시스템 레벨에서 발생하는 심각한 오류로, 개발자가 직접 처리하기 어렵습니다. (예: `OutOfMemoryError`, `StackOverflowError`)
    * **`Exception`**: 프로그램 코드에 의해 발생하며, 개발자가 예측하고 처리할 수 있는 오류입니다.
        * **Checked Exception (확인 예외)**: 컴파일 시점에서 확인되며, 반드시 `try-catch`로 처리하거나 `throws`로 선언해야 합니다. (예: `IOException`, `SQLException`)
        * **Unchecked Exception (비확인 예외)**: 런타임 시점에서 발생하며, 컴파일러가 예외 처리 여부를 강제하지 않습니다. 개발자의 실수로 인해 주로 발생합니다. (예: `NullPointerException`, `ArrayIndexOutOfBoundsException`)
* **예외 처리 구문**:
    * **`try-catch-finally`**: 예외 발생 가능성이 있는 코드를 `try` 블록에, 예외 발생 시 처리할 코드를 `catch` 블록에, 예외 발생 여부와 상관없이 항상 실행될 코드를 `finally` 블록에 작성합니다.
    * **`throws`**: 메서드 선언부에 사용하여 해당 메서드에서 발생할 수 있는 예외를 호출한 쪽에 던진다는 것을 명시합니다.
    * **`throw`**: 강제로 예외를 발생시킬 때 사용합니다.

---

### 동시성(Concurrency) 및 멀티스레딩 심화

**멀티스레딩**은 하나의 프로세스 내에서 여러 개의 스레드가 동시에 작업을 수행하여 시스템 자원을 효율적으로 사용하고 응답성을 높이는 기술입니다. **동시성(Concurrency)**은 여러 작업이 동시에 실행되는 것처럼 보이게 하는 개념입니다.

* **`synchronized` 키워드**: 멀티스레드 환경에서 공유 자원에 대한 접근을 제어하여 **스레드 동기화**를 보장합니다. 메서드나 블록에 사용하여 한 번에 하나의 스레드만 해당 코드 영역을 실행할 수 있도록 락(Lock)을 겁니다.
* **`volatile` 키워드**: 변수의 값을 메인 메모리에 직접 동기화하도록 강제하여, 여러 스레드가 변수 값을 캐시하지 않고 항상 최신 값을 읽도록 보장합니다. 스레드 가시성 문제를 해결합니다.
* **스레드 동기화 문제**:
    * **경쟁 조건 (Race Condition)**: 여러 스레드가 동시에 공유 자원에 접근하여 예상치 못한 결과를 초래하는 문제.
    * **데드락 (Deadlock)**: 두 개 이상의 스레드가 서로의 락을 기다리며 영원히 멈춰버리는 현상.
* **`java.util.concurrent` 패키지**: 자바 5부터 추가된 동시성 유틸리티 패키지로, 스레드 풀, 큐, 동기화 도구 등을 제공하여 복잡한 동시성 프로그래밍을 더 쉽게 할 수 있도록 돕습니다. (예: `ExecutorService`, `Future`, `Semaphore`, `CountDownLatch`)

---

### 객체 지향 프로그래밍(OOP) 5대 원칙 (SOLID)

OOP의 설계 원칙으로, 유지보수와 확장이 쉬운 시스템을 구축하는 데 도움이 됩니다.

* **SRP (Single Responsibility Principle - 단일 책임 원칙)**: 클래스는 오직 하나의 책임만 가져야 합니다.
* **OCP (Open-Closed Principle - 개방-폐쇄 원칙)**: 확장에 대해서는 개방되어 있고, 변경에 대해서는 폐쇄되어야 합니다. (기존 코드를 변경하지 않고 기능을 확장할 수 있어야 함)
* **LSP (Liskov Substitution Principle - 리스코프 치환 원칙)**: 부모 클래스와 자식 클래스 간에는 행위의 호환성이 있어야 합니다. 즉, 부모 타입의 객체를 자식 타입의 객체로 치환해도 프로그램의 동작이 일관되어야 합니다.
* **ISP (Interface Segregation Principle - 인터페이스 분리 원칙)**: 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 됩니다. (큰 인터페이스를 작은 인터페이스로 분리)
* **DIP (Dependency Inversion Principle - 의존성 역전 원칙)**: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다. 추상화는 세부 사항에 의존해서는 안 되며, 세부 사항이 추상화에 의존해야 합니다.

---

### 직렬화(Serialization)

**직렬화**는 자바 객체를 바이트 스트림으로 변환하여 파일에 저장하거나 네트워크를 통해 전송할 수 있도록 하는 과정입니다. 반대로 바이트 스트림을 다시 객체로 변환하는 것을 **역직렬화(Deserialization)**라고 합니다.

* **목적**:
    * 객체를 영속적으로 저장 (파일 시스템에 저장)
    * 다른 JVM이나 다른 시스템으로 객체 전송
* **구현**: `java.io.Serializable` 인터페이스를 구현하는 것으로 간단하게 직렬화가 가능합니다.
* **`transient` 키워드**: 직렬화 과정에서 특정 필드를 제외하고 싶을 때 사용합니다. `transient`로 선언된 필드는 직렬화되지 않습니다.

---

### 스트림(Stream API)

**자바 8**부터 추가된 **Stream API**는 컬렉션이나 배열 등의 데이터를 **선언형**으로 처리할 수 있는 기능을 제공합니다. 데이터를 추상화하여 필터링, 매핑, 정렬 등 다양한 연산을 파이프라인 형태로 연결하여 처리할 수 있게 합니다.

* **특징**:
    * **원본 데이터를 변경하지 않음**: 스트림 연산은 새로운 스트림을 생성하며, 원본 데이터는 보존됩니다.
    * **내부 반복**: 반복문을 직접 작성하지 않고도 컬렉션의 요소를 처리합니다.
    * **지연 연산 (Lazy Evaluation)**: 최종 연산이 호출되기 전까지는 중간 연산이 실행되지 않습니다.
    * **병렬 처리 가능**: 병렬 스트림을 통해 멀티코어 프로세서의 이점을 활용할 수 있습니다.
* **구성**:
    * **스트림 생성**: 컬렉션의 `stream()` 메서드, `Arrays.stream()`, `Stream.of()` 등
    * **중간 연산 (Intermediate Operations)**: 스트림을 변환하거나 필터링하는 연산으로, 스트림을 반환하여 연속적으로 연결 가능합니다. (예: `filter()`, `map()`, `sorted()`, `distinct()`)
    * **최종 연산 (Terminal Operations)**: 스트림 파이프라인을 종료하고 결과를 생성합니다. (예: `forEach()`, `collect()`, `reduce()`, `count()`, `sum()`, `min()`, `max()`)

---

### Optional 클래스

**자바 8**에 도입된 `Optional` 클래스는 **`null` 값을 안전하게 다루기 위한** 컨테이너 클래스입니다. `null`이 올 수 있는 값을 감싸서 `null` 포인터 예외(`NullPointerException`)를 방지하고, 코드의 가독성을 높여줍니다.

* **주요 메서드**:
    * `Optional.of(value)`: `null`이 아닌 값을 포함하는 Optional 생성. (값이 `null`이면 `NullPointerException` 발생)
    * `Optional.ofNullable(value)`: `null`일 수도 있는 값을 포함하는 Optional 생성.
    * `isPresent()`: Optional이 값을 포함하고 있는지 여부를 반환.
    * `get()`: Optional에 포함된 값을 반환. (값이 없으면 `NoSuchElementException` 발생)
    * `orElse(defaultValue)`: 값이 없으면 기본값을 반환.
    * `ifPresent(consumer)`: 값이 있으면 Consumer 람다식을 실행.

---

### 람다식(Lambda Expression)

**자바 8**에서 도입된 **람다식**은 익명 함수를 간결하게 표현하는 방법입니다. 코드를 간략화하고, 컬렉션 처리와 같은 부분에서 함수형 프로그래밍 스타일을 가능하게 합니다.

* **특징**:
    * **익명 함수**: 이름이 없는 함수입니다.
    * **함수형 인터페이스**: 람다식은 하나의 추상 메서드만 가진 **함수형 인터페이스**의 구현체로 사용됩니다.
    * **코드 간결화**: 불필요한 코드(클래스 선언, 메서드 오버라이드 등)를 줄여 코드를 간결하게 만듭니다.
* **기본 문법**: `(매개변수) -> { 실행코드 }`
* **익명 클래스와의 비교**: 익명 클래스보다 훨씬 간결하게 코드를 작성할 수 있으며, 클로저(Closure)를 지원합니다.

---
